# 자바스크립트 중급 강좌: 140분 완성

Created: 2022년 1월 9일 오전 2:31
Last Edited Time: 2022년 1월 11일 오후 10:10
Status: In Progress
참조: https://www.youtube.com/watch?v=4_WLS9Lj6n4

Ⅰ. 변수, 호이스팅, TDZ(Temporal Dead Zone)

```jsx
//변수
let
const
var

// var
// 1. var는 한번 선언된 변수를 다시 선언할 수 있다.
var name = 'Mike';
console.log(name); // "Mike"

var name = 'Jane';
console.log(name); // "Jane"

// 2. var는 선언하기 전에 사용할 수 있다.
console.log(name); // undefined
var name = 'Mike';

// 사실 위의 코드는
var name;
console.log(name); // undefined
name = 'Mike';
// 이를 호이스팅(hoisting) 이라 한다.
// 🌐호이스팅(hoisting): 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것 처럼 행동
// console.log() 에서 undefined가 되는 이유는
// 선언은 호이스팅(hoisting)이 되지만, 할당은 되지 않는다.

// let 이라면?
console.log(name); // ReferenceError
let name = 'Mike';
// 사실 let도 호이스팅(hoisting)이 됨.
// 하지만 var 처럼 사용할 수 없음 
// 왜❓❓❓

TDZ(Temporal Dead Zone)
console.log(name); // Temporal Dead Zone
const name = 'Mike'; // 함수 선언 및 할당
console.log(name); // 사용 가능
// let 과 const 는 TDZ(Temporal Dead Zone)의 영향을 받음
// TDZ 덕분에 코드를 예측 가능하게하고
// 잠재적인 버그를 예방할 수 있음

// 호이스팅
let age = 30;

//---------스코프----------
function showAge(){
	//-------TDZ(Temporal Dead Zone)-------
	console.log(age);
	//-------------------------------------
	let age = 20; // 오류 발생
}
//---------스코프----------

showAge();

변수의 생성과정
// 1. 선언 단계
// 2. 초기화 단계
// 3. 할당 단계

var
// 1. 선언과 초기화 단계가 동시에 이루어짐
// 2. 할당 단계
🌐초기화: undefined 를 할당 해주는 단계

let
// 1. 선언 단계
// 2. 초기화 단계
// 3. 할당 단계

const
// 1. 선언 + 초기화 + 할당

//const
let name;
name = 'Mike';

var age;
age = 30;

const gender;
gender = 'male'; // Uncaught SyntaxError: Missing initializer in const declaration

// 스코프
var
: 함수 스코프(function-scoped)
// 함수 스코프(function-scoped)
// 함수 내에서 선언된 변수만 지역변수가 됨.

let, const
: 블록 스코프(block-scoped)
// 블록 스코프(block-scoped)
// 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)에서 선언된 변수(지역변수)는 코드 블록내에서만 유효하다.
// 외부에서는 접근할 수 없다.
function add(){
	// Block-level Scope
}
if(){
	// Block-level Scope
}
for(){
	// Block-level Scope
}

//ex.1)
const age = 30;

if(age > 19){
	var txt = '성인';
}

console.log(txt); // "성인"

//ex.2)
function add(num1, num2){
	var result = num1 + num2;
}
add(1,2);
console.log(result); // Uncaught ReferenceError: result in not defined
// 위의 오류가 뜨는 까닭은
// var 변수가 현재 함수 스코프안에 있기 때문에
// var 변수를 전역변수로 사용할 수 없다.
```

Ⅱ. 생성자 함수

```jsx
// 객체 리터럴
let user = {
	name: 'Mike',
	age: 30,
}
// 위와 같은 객체를 여러개 만들어야 한다면❓❓❓

// 생성자 함수
function User(_name, _age){ // 생성자 함수는 "첫 글자는 대문자로"
	this.name = _name;
	this.age = _age;
}

// new 연산자를 사용해서 함수를 호출
let user1 = new User('Mike', 30); // User {name: "Mike", age: 30}
let user2 = new User('Jane', 22); // User {name: "Jane", age: 22}
let user3 = new User('Tom', 17); // User {name: "Tom", age: 17}

// 생성자 함수 동작 방법
function User(name, age){
	// 2. this = {}, "빈 객체"를 만들고 "this"에 할당함
	this.name = name; // 3. 함수를 실행하면서 this에 Property를 할당함
	this.age = age;

	return this; // 4. this를 반환함.
}

// 1. new 함수명(); 실행

// ❗❗생성자 함수의 장점❗❗
// 객체를 빠르게 생성할 수 있음.
// 객체를 일관성있게 만들 수 있음.
// 스펙이 변경되어도 생성자 함수만 수정하면 됨.

// 생성자 함수 Property에 함수 추가하기
function User(_name, _age){
	this.name = _name;
	this.age = _age;
	this.sayHello = function(){
			console.log(this.name); // this == user5
	}
}

let user5 = new User('Han', 40);
user5.sayHello(); // "Han"

//ex.1)
function Item(title, price){
	// this = {};

	this.title = title;
	this.price = price;
	this.showPrice = function(){
		console.log(`가격은 ${price}원 입니다.`);
	}
	// return this;
}

const item1 = new Item('인형', 3000);
const item2 = new Item('가방', 1000);
const item3 = new Item('지갑', 2000);

console.log(item1, item2, item3);
// Item {title: "인형", price: 3000, showPrice: f}
// Item {title: "가방", price: 1000, showPrice: f}
// Item {title: "지갑", price: 2000, showPrice: f}

item3.showPrice(); // "가격은 2000원 입니다."
```

Ⅲ. 객체 메소드(Object methods), 계산된 프로퍼티(computed property)

```jsx
// 계산된 프로퍼티(computed property)
// ex.1)
let n = 'name';
let a = 'age';

const user = {
	[n] : 'Mike', // name : 'Mike', [n] == name
	[a] : 30 // age : 30, [a] == age
}

// ex.2)
const user = {
	[1 + 4] : 5,
	["안녕" + "하세요"] : "Hello"
}
console.log(user); // user {5: 5, 안녕하세요: "Hello"};

// ex.3)
function makeObj(_key, val){
	return {
		[_key]: val
	};
}

const obj = makeObj("성별", "male");
console.log(obj); // {성별: "male"}

// key값에 어떤 값이 들어올지 모를 때 사용하면 유용함❗❗❗

// 객체 메소드(Object methods)
// Object.assign() : 객체 복제
const user = { // 객체는 메모리에 저장되고 변수에는 해당 메모리의 주소값만 저장된다!!
	name : 'Mike',
	age : 30
}

const newUser = Object.assign({}, user);
// 1번째 인자 {}는 초기값, 
// 2번째 인자 user는 복제할 대상
// {} + {name: 'Mike', age: 30} = 

newUser.name = 'Tom'
console.log(user.name); // "Mike"
newUser != user // newUser 와 user 는 같은 객체가 아니다.

// 없는 프로퍼티를 초기화값에 넣으면 기존 프로퍼티 위에 추가된다.
const newUser = Object.assign({gender: 'male'}, user);
newUser = {
	gender: 'male',
	name : 'Mike',
	age : 30
}

// 만약 병합을 하는데 key 값이 같다면❓❓❓
const newUser = Object.assign({name: 'Tom'}, user);
newUser = {
	// name: 'Tom' 은 덮어씌워짐
	name : 'Mike',
	age : 30
}

// 여러 객체를 하나의 객체에 합칠 수 있음
const user = {
	name: 'Mike'
}
const info1 = {
	age: 30
}
const info2 = {
	gender: 'male'
}

Object.assign(user, info1, info2); // user 라는 객체로 info1, info2의 프로터피가 복사됨.

// Object.keys(): 키(key) 배열 반환
const user = {
	name : 'Mike',
	age : 30
	gender: 'male'
}

Object.keys(user); // ["name", "age", "gender"]

// Object.values(): 값(value) 배열 반환
const user = {
	name : 'Mike',
	age : 30
	gender: 'male'
}

Object.values(user); // ["Mike", 30, "male"]

// Object.entries(): 키/값 배열 반환
const user = {
	name : 'Mike',
	age : 30
	gender: 'male'
}

Object.entries(user); // [["name", "Mike"], ["age", 30], ["gender", "male"]]

// Object.fromRentries(): 키/값 배열을 객체로
const arr = [
	["name", "Mike"],
	["age", 30],
	["gender", "male"]
];

Object.fromRentries(arr); // {name: 'Mike', age: 30, gender: 'male'}

// ex.1)
let arr = [
	['mon', '월'],
	['tue', '화']
];

const result = Object.fromRentries(arr);
console.log(result); // {mon: '월', tue: '화'}
```

Ⅳ. 심볼(Symbol)☢☢☢

```jsx
// property key: 문자형
const obj = {
	1 : '1입니다.',
	false : '거짓'
}

Object.keys(obj); // ["1", "false"], key 값이 문자열인걸 알 수 있음.
obj['1']; // "1 입니다."
obj['false']; // "거짓"

// Symbol
// Symbol은 "유일한 식별자"를 만들때 사용한다.
const a = Symbol(); // new 를 붙이지 않는다❗❗❗
const b = Symbol();

console.log(a); // Symbol()
console.log(b); // Symbol()

a === b; // false
a == b; // false

// Symbol은 "유일성" 보장
// 전체 코트 중 딱 1개만 가능, 유일한 property를 사용하고 싶을 때 사용
const id = Symbol('id'); // 해당 심볼에 대한 설명을 중괄호() 안에 작성함, 
												 // 설명은 "문자열로 작성", Symbol 생성에는 어떠한 영향도 끼치지 않음
// 설명이 똑같은 Symbol을 만든다면❓❓
const id2 = Symbol('id');

console.log(id); // Symbol(id)
console.log(id2); // Symbol(id)

id === id2; // false
id == id2; // false

// property key: 심볼형
// Symbol을 객체의 key로 사용가능
const id = Symbol('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
}

console.log(user); // {name: "Mike", age: 30, Symbol(id): "myid"}
user[id]; // "myid"
Object.keys(user); // ["name", "age"], Symbol 프로퍼티 건너뜀
Object.values(user); // ["Mike", 30], Symbol 프로퍼티 건너뜀
Object.entries(user); // [Array(2), Array(2)], Symbol 프로퍼티 건너뜀

// 이런 점을 활용해서 특정 객체의 원본 데이터를 건드리지 않고 Property를 추가할 수 있음
const user = {
	name: 'Mike',
	age: 30
}

const id = Symbol('id');
user[id] = 'myid';

console.log(user); // {name: 'Mike', age: 30, Symbol(id): 'myid'}

// Symbol.for() : 전역 심볼
// 하나의 Symbol만 보장받을 수 있음
// 없으면 만들고, 있으면 가져오기 때문
// Symbol 함수는 매번 다른 Symbol 값을 생성하지만,
// Symbol.for 메소드는 하나를 생성한 뒤 키를 통해 같은 Symbol을 공유
// 코드 어디에서든 사용 가능
const id1 = Symbol.for('id');
const id2 = Symbol.for('id');
id1 === id2; // true

// Symbol.keyFor(): Symbol의 이름을 얻을 때
Symbol.keyFor(id1); // "id"

// description
// 전역 심볼이 아닌 Symbol은 keyFor()를 사용할 수 없음
const id = Symbol('id 입니다.');
id.description; // "id 입니다."

// 숨겨진 Symbol key 보는 법
// Symbol를 완전히 숨기는 방법은 ❌
const id = Symbol('id');
const user = {
	name: 'Mike',
	age: 30,
	[id]: 'myid'
}

Object.getOwnPropertySymbols(user); // [Symbol(id)], 숨겨진 Symbol를 보여줌
Reflect.ownKeys(user); // ["name", "age", Symbol(id)], Symbol를 포함한 객체의 모든 Key를 배열로 보여줌

// ex.1)
// 다른 개발자가 만들어 놓은 객체
const user = {
	name: 'Mike',
	age: 30,
}

// 내가 작업
user.showName = function(){}; // His showName is function(){}.
// 아래 사용자가 접속했을 때 위와 같은 이상한 메세지를 볼 수 있음.
// 이럴떄 Symbol 사용
const showName = Symbol("showName");
user[showName] = function(){
	console.log(this.name); // Symbol로 만들어졌기 때문에 보이지 않음.
};

user[showName](); // "Mike"

// 사용자가 접속하면 보는 메세지
for(let key in user){
	console.log(`His ${key} is ${user[key]}.`); // "His name is Mike.", "His age is 30."
}

// 다른 개발자가 만들어놓은 코드에 내가 작업을 하는 경우
// 다른 코드에 영향을 끼치지 않으면서 내가 만든 코드를 정상적으로 실행할 수 있음.
```

Ⅴ. 숫자(Number), 수학(Math)

```jsx
// toStinng()
// 10진수 -> 2진수 or 16진수 변환
let num = 10;
num.toString(); // "10"
num.toString(2); // "1010", 중괄호() 안에 숫자를 쓰면, 해당 숫자의 진법으로 변환, 10를 2진수로 나타냄

let num2 = 255;
num.toString(16); // "ff"

// 수학(Math)
Math.PI; // 3.141592653589793

// Math.ceil(): 올림
let num1 = 5.1;
let num2 = 5.7;

Math.ceil(num1); // 6
Math.ceil(num2); // 6

// Math.floor(): 내림
let num1 = 5.1;
let num2 = 5.7;

Math.floor(num1); // 5
Math.floor(num2); // 5

// Math.round(): 반올림
let num1 = 5.1;
let num2 = 5.7;

Math.round(num1); // 5
Math.round(num2); // 6

// 소수점 자릿수
let userRate = 30.1234;
// 요구사항: 소수점 "둘째자리"까지 표현(셋째 자리에서 반올림)

userRate * 100 // 3012.34
Math.round(userRate * 100); // 3012
Math.round(userRate * 100)/100; // 30.12

// 소수점 자릿수: toFixed()
let userRate = 30.1234;
// 요구사항: 소수점 "둘째자리"까지 표현(셋째 자리에서 반올림)
userRate.toFixed(2); // "30.12"
userRate.toFixed(0); // "30"
userRate.toFixed(6); // "30.123400"
// 🛑toFixed() 주의사항🛑 : "문자열"로 반환함
// Number()를 이용해 숫자로 변환해야함❗❗
Number(userRate.toFixed(2)); // 30.12

// isNaN(): NaN인지 아닌지 판단해줌
// isNaN()만이 NaN인지 아닌지 판단할 수 있는 유일한 메소드❗❗
let x = Number('x'); // NaN
x == NaN; // false
x === NaN; // false
NaN == NaN; // false

isNaN(x) // true, Nan이다
isNaN(3) // false, 숫자맞다

// paeseInt(): 문자열을 숫자로 바꿔줌
let margin = '10px';
parseInt(margin); // 10, 문자가 혼용되어 있어도 동작⭕
Number(margin); // NaN, 문자가 혼용되어 있으면 동장❌

let redColor = 'f3';
parseInt(redColor); // NaN, 문자로 시작하게 되면 변환할 수 없음

let redColor = 'f3';
parseInt(redColor, 16); // 243, parseInt()의 2번째 인수에 16를 넣어 해당 값을 16진수로 나타냄

parseInt('11', 2); // 3, 문자열 "11"를 숫자로 바꾸고, 2진수로 나타냄.

// parseFloat()
let padding = '18.5%';
parseInt(padding); // 18, 소수점 이하는 버리고 정수만 반환
parseFloat(padding); // 18.5, parseInt()와 동일하게 작동하지만, 부동소수점을 반환함

// Math.random()
// 0 ~ 1 사이 무작위 숫자 생성
Math.random(); // 0.25679794564897
Math.random(); // 0.41248765123132
Math.random(); // 0.87456486231321

// 1 ~ 100 사이 임의의 숫자를 뽑고 싶다면❓❓
Math.floor(Math.random()*100)+1 
// Math.random(): 0.6789
// Math.random()*100: 0.6789 * 100 == 67.89
// Math.floor(67.89) == 67
// 67 + 1 = 68, +1 하기 전에는 0 ~ 99 상태임. 조건인 1 ~ 100를 만들기 위해서 1를 더함.

// Math.max() / Math.min()
// 괄호안의 숫자 중 최대값 / 최소값을 구함
Math.max(1, 4, -1, 5, 10, 9, 5.54); // 10
Math.min(1, 4, -1, 5, 10, 9, 5.54); // -1

// Math.abs();
// 절대값을 구함
Math.abs(-1); // 1

//Math.pow(n,m); 
// n의 m승 값, 거듭제곱 해줌
Math.pow(2, 10); // 1024

// Math.sqrt();
// 제곱근
Math.sqrt(16); // 4
```

Ⅵ. 문자열 메소드(String methods)

```jsx
let html = '<div class="box_little">제목 영역</div>';
// html 코드의 경우 ''(작은 따움표)로 감싸는게 좋다.
// 코드안에 ""(큰따움표)가 쓰이기 때문에

let desc = "It's 3 o'clock."
// 영어 문장의 경우 ""(큰따움표)로 감싸는게 좋다
// ''(작은 따움표)를 사용 경우가 있기 때문에

// (``)백틱
// 여러 줄로 표현 가능
let desc = `오늘은 맑고 화창한
날씨가 계속 되겠습니다.
내일은 비소식이 있습니다.`;

let desc = '오늘은 맑고 화창한 \n날씨가 계속 되겠습니다. \n내일은 비소식이 있습니다.';

let desc = '오늘은 맑고 화창한 // Error!
날씨가 계속 되겠습니다.
내일은 비소식이 있습니다.';

// length: 문자열 길이
let desc = '안녕하세여.';
desc.length; // 6

// 특정 위치에 접근
let desc = '안녕하세여.';
desc[2]; // '하'

desc[4] = '용';
console.log(desc); // '안녕하세여.', 변화 없음

// toUpperCase() / toLowerCase()
// 영어인 경우 대문자 / 소문자로 변환할 수 있음
let desc = "Hi guys. Nice to meet you.";
desc.toUpperCase(); // "HI GUYS. NICE TO MEET YOU.";
desc.toLowerCase(); // "hi guys. nice to meet you.";

// str.indexOf(text)
// 인수를 문자로 받아 해당 문자가 몇번째에 위치하는지 알려줌
let desc = "Hi guys. Nice to meet you.";
desc.indexOf('to'); // 14
desc.indexOf('man'); // -1, 찾는 문자가 없으면 -1를 반환함.
// ⚠주의사항⚠
// 찾는 문자가 여러개라도, 찾는 문자의 첫번째 위치만 반환한다❗❗
//if문을 사용할 때 주의❗❗
if(desc.indexOf('Hi')){ // desc.indexOf('Hi') == 0, if에서 0은 false
	console.log('Hi가 포함된  문장입니다.'); // console.log가 찍히지 않고 바료 종료됨
}
// 개선
if(desc.indexOf('Hi') > -1){ // -1 보다 큰지를 넣어준다.
	console.log('Hi가 포함된  문장입니다.'); // console.log가 찍히지 않고 바료 종료됨
}

// str.slice(n, m)
// n은 시작점
// m, 없으면 문자열 끝까지, 양수면 그 숫자까지(포함하지 않음), 음수면 끝에서부터 셈
let desc = "abcdefg";
desc.slice(2); // "cdefg"
desc.slice(0, 5); // "abcde"
desc.slice(2, -2); // "cde", 끝에서 2번째 위치까지 반환

// str.substring(n, m)
// n과 m 사이 문자열 반환
// n과 m 을 바꿔도 동작함
// 음수는 0으로 인식
let desc = "abcdefg";
desc.substring(2, 5); // "cde"
desc.substring(5, 2); // "cde"

// str.substr(n, m)
// n 부터 시작
// m 개를 가져옴(범위X, 갯수임)
let desc = "abcdefg";
desc.substr(2, 4); // "cdef"
desc.substr(-4, 2); // "de"

// str.trim()
// 앞, 뒤 공백 제거
let desc = " coding       ";
desc.trim(); // "coding"

// str.repeat(n)
// 문자열을 n번 반복함
let hello = "hello!";
hello.repeat(3); // "hello!hello!hello!"

// 문자열 비교
1 < 3 // true
"a" < "c" // true
"a".codePointAt(0); // 97
"c".codePointAt(0); // 99

String.fromCodePoint(97) // "a"

// ex.1)
let list = [
	"01. 들어가며",
	"02. JS의 역사",
	"03. 자료형",
	"04. 함수",
	"05. 배열"
];

let newList = [];
for(let i = 0; i < list.length; i++;){
	newList.push(
		list[i].slice(4)
	);
}
console.log(newList); // ["들어가며", "JS의 역사", "자료형", "함수", "배열"]

// ex.2)
// 금칙어 : 콜라
function hasCola(str){
	if(str.indexOf('콜라')){
		console.log('금칙어가 있습니다.');
	} else {
		console.log('통과');
	}
}

hasCola('와 사이다가 짱이야!'); // '금칙어가 있습니다.'
// str.indexOf('콜라')에 -1이 되버리기 때문❗❗
hasCola('노인정. 콜라가 짱이라능!'); //'금칙어가 있습니다.' 
hasCola('콜라'); // '통과'❓❓
// str.indexOf('콜라')가 0이 되버리기 때문❗❗

// 개선
function hasCola(str){
	if(str.indexOf('콜라') > -1){
		console.log('금칙어가 있습니다.');
	} else {
		console.log('통과');
	}
}
hasCola('와 사이다가 짱이야!'); // '통과'
hasCola('노인정. 콜라가 짱이라능!'); // '금칙어가 있습니다.' 
hasCola('콜라'); // '금칙어가 있습니다.' 

// ex.3)
// 금칙어 : 콜라
// includes
// 문자가 있으면 true
// 문자가 없으면 false
function hasCola(str){
	if(str.includes('콜라')){
		console.log('금칙어가 있습니다.');
	} else {
		console.log('통과');
	}
}
hasCola('와 사이다가 짱이야!'); // '통과'
hasCola('노인정. 콜라가 짱이라능!'); // '금칙어가 있습니다.' 
hasCola('콜라'); // '금칙어가 있습니다.' 

```

Ⅶ. 배열 메소드1(Array methodes)

```jsx
// Array
// push(): 뒤에 삽입
// pop(): 뒤에 삭제
// unshift(): 앞에 삽입
// shift(): 앞에 삭제

// arr.splice(n, m)
// 특정 요소 지움
// n번째 부터, m개를 지움.
let arr = [0, 1, 2, 3, 4, 5];
arr.splice(1, 2);

console.log(arr); // [1, 4, 5]

// arr.splice(n, m,  x)
// 특정 요소 지우고 추가
let arr = [1, 2, 3, 4, 5];
arr.splice(1, 3, 100, 200);
console.log(arr); // [1, 100, 200, 5]

let arr = ["나는", "철수", "입니다."];
arr.splice(1, 0, "대한민국", "소방관");
console.log(arr); // ["나는", "대한민국", "소방관", "철수", "입니다."]

// arr.splice()
// 삭제된 요소 반환
let arr = [1, 2, 3, 4, 5];
let result = arr.splice(1, 2);

console.log(arr); // [1, 4, 5]
console.log(result); // [2, 3]

// arr.slice(n, m)
// n부터 m까지 반환
let arr = [1, 2, 3, 4, 5];
arr.slice(1, 4); // [2, 3, 4]

// 만약 slice()안에 아무것도 쓰지 않는다면❓❓❓
let arr2 = arr.slice();
console.log(arr2); // [1, 2, 3, 4, 5]

// arr.concat(arr2, arr3, ...)
// 인자들을 합쳐서 새배열로 반환
let arr = [1, 2];
arr.concat([3, 4]); // [1, 2, 3, 4]
arr.concat([3, 4], [5, 6]); // [1, 2, 3, 4, 5, 6]
arr.concat([3, 4], 5, 6); // [1, 2, 3, 4, 5, 6]

// 🌐arr.forEach(fn)
// 배열의 반복
// forEach() 함수를 받고 인수로 매개변수를 받음 
let users = ['Mike', 'Tom', 'Jane'];
users.forEach((item, index, arr) => {
// item: 'Mike', 'Tom', 'Jane', 해당 요소
// index: 0, 1, 2, 인덱스
// arr: users, 해당 배열 자체, 잘 사용X
	// ...
});

// ex.1)
let users = ['Mike', 'Tom', 'Jane'];
users.forEach((name, index) => {
	console.log(`${index +  1}. ${name}`); // 1. Mike, 2. Tom, 3. Jane
});

// arr.indexOf / arr.lastIndexOf
// indexOf(): 중괄호() 안 인덱스에 해당하는 요소를 반환, 없으면 -1를 반환
let arr = [1, 2, 3, 4, 5, 1, 2, 3];

arr.indexOf(3); // 2
arr.indexOf(3, 3); // 7, 2번째 인수는 찾는 시작 위치를 뜻함

// lastIndexOf(): 끝에서 부터 찾음.
arr.lastIndexOf(3); // 7

// arr.includes()
// 포함하는지 확인
let arr = [1, 2, 3];
arr.includes(2); // true
arr.includes(8); // false

// arr.find(fn) / arr.findIndex(fn)
// indexOf()처럼 찾는다는 의미는 동일하지만
// 보다 복잡한 연산이 가능하도록 함수를 연결할 수 있음 ex)짝수 찾기, 성인찾기 등등
// ⚠주의사항⚠
// 첫번째 true 값만 반환하고 끝
// 만약 없으면 undefined를 반환
// ex.1)
let arr = [1, 2, 3, 4, 5];

const result = arr.find((item) => {
	return item % 2 === 0; // 짝수를 찾아서 반환함
});

console.log(result); // 2, 첫번째 true값인 2만 반환하고 끝냄

// ex.2)
let userList = [
	{name: "Mike", age: 30},
	{name: "Jane", age: 27},
	{name: "Tom", age: 10}
];

const result = userList.find((user) => {
	if(user.age < 19){
		return true;
	}
	return false;
});

console.log(result); // {name: "Tom", age: 10}

// ex.3)
let userList = [
	{name: "Mike", age: 30},
	{name: "Jane", age: 27},
	{name: "Tom", age: 10}
];

const result = userList.findIndex((user) => {
	if(user.age < 19){
		return true;
	}
	return false;
});

console.log(result); // 2, userList 중에서 2번째 인덱스가 true, 즉 미성년이란걸 알려줌

// arr.filter(fn)
// 만족하는 모든 요소를 배열로 반환
let arr = [1, 2, 3, 4, 5, 6];

const result = arr.filter((item) => {
	return item % 2 === 0; // 짝수를 찾아서 반환함
});

console.log(result); // [2, 4, 6]

// arr.reverse()
// 배열을 역순으로 재정렬
let arr = [1, 2, 3, 4, 5];
arr.reverse(); // [5, 4, 3, 2, 1]

// 🌐arr.map(fn)
// 함수를 받아 특정 기능을 시행하고, 새로운 배열을 반환
let userList = [
	{name: "Mike", age: 30},
	{name: "Jane", age: 27},
	{name: "Tom", age: 10}
];

let newUserList = userList.map((user, index) => {
	return Object.assign({}, user, {
		id : index + 1,
		isAdult : user.age > 19
	});
});

console.log(newUserList);
// {name: "Mike", age: 30, id: 1, isAdult: true}
// {name: "Jane", age: 27, id: 2, isAdult: true}
// {name: "Tom", age: 10, id: 3, isAdult: false}
console.log(userList);
// {name: "Mike", age: 30}
// {name: "Jane", age: 27}
// {name: "Tom", age: 10}

// arr.join() / arr.split()
// arr.join()
// 배열의 문자열을 합침
let arr = ["안녕", "나는", "철수야"];
let result = arr.join("-");
console.log(result); // "안녕-나는-철수야"

// arr.split()
// 문자열을 나눠 배열로 반환
const users = "Mike, Jane, Tom, Tony";
const result = users.split(","); // 중괄호() 안에 어떤 문자를 기준으로 나눌것인지 지정
// 빈 문자열("")로 지정하면, 글자 하나하나, 띄어쓰기 하나하나 모두 배열로 반환함.
console.log(result); // ["Mike", "Jane", "Tom", "Tony"]

// Array.isArray()
// 배열인지 아닌지 확인
let user ={
	name: "Mike",
	age: 30,
};

let userList = ["Mike", "Tom", "Jane"];

console.log(typeof user); // object
console.log(typeof userList); // object

console.log(Array.isArray(user)); // false
console.log(Array.isArray(userList)); // true
```

Ⅷ. 배열 메소드2((Array methodes)

```jsx
// arr.sort() / arr.reduce()

// arr.sort()
// 배열 재정렬
// 배열 자체가 변경되지 주의⚠⚠⚠
// 인수로 정렬 로직을 담은 함수를 받음
// 숫자
let arr = [1, 5, 3, 2, 4];
arr.sort();
console.log(arr); // [1, 2, 3, 4, 5]
// 알파벳
let alf = ["a", "e", "c", "b", "d"];
alf.sort();
console.log(alf); // ["a", "b", "c", "d", "e"]

// ex.1)
let arr = [27, 8, 5, 13];
arr.sort();
console.log(arr); // [13, 27, 5, 8]
// 개선
let arr = [27, 8, 5, 13];

/*function fn(a, b){
	return a - b;
}*/

arr.sort((a, b) => { // 1. 2개의 요소를 각각 a,b에 전달하고
	return a - b; // 2. 크기를 비교해서 양수인지, 0인지, 음수인지 알려주면 됨
// 3. a 와 b를 비교해서, a가 작으면 앞으로, 0를 반환하면 가만히, a가 크면 b가 더 큰 것으로 b를 앞으로
});
console.log(arr); // [5, 8, 13, 27]

// 실무에서는 🌐[Lodash](https://lodash.com/)🌐를 사용해서 간단하게 해결함

// arr.reduce()
// 인수를 함수로 받음
// (누적 계산값, 현재값) => { return 계산값 };

// 배열의 모든 수 합치기
let arr = [1, 2, 3, 4, 5];

// for, for of, forEach
let result = 0;
arr.forEach(num => {
	// result += result + num
	result += num;
});

console.log(result); // 15

// reduce() 사용
const result = arr.reduce((prev, cur) => { // prev: 이전값, cur: 현재값
	return preㅍ + cur;
}, 0); // 초기값 0 설정, 옵션임으로 안써도됨. 안쓸 경우 첫번째 요소가 초기값 됨.

console.log(result); // 15

// ex.1)
let userList = [
	{name: "Mike", age: 30},
	{name: "Tom", age: 10},
	{name: "Jane", age: 27},
	{name: "Sue", age: 26},
	{name: "Harry", age: 42},
	{name: "Steve", age: 60},
];

// 성인인 경우만 배열로 반환
let result = userList.reduce((prev, cur) => {
	if(cur.age > 19){
		prev.push(cur.name);
	}
	return prev;
}, []);

console.log(result); // ["Mike", "Jane", "Sue", "Harry", "Steve"]

// 나이를 전부 합산
let result = userList.reduce((prev, cur) => {
	return (prev += cur.age);
}, 0);

console.log(result); // 196

// 이름이 3자인 사람만 배열로 반홤
let result = userList.reduce((prev, cur) => {
	if(cur.name.length === 3){
		prev.push(cur.name);
	}
	return prev;
}, []);

console.log(result); // ["Tom", "Sue"]

// arr.reduceRight()
// 배열의 오른쪽에서 왼쪽으로 정렬
const  arr1 = [0, 1, 2, 3, 4, 5];
arr1.reduceRight();
console.log(arr1); // [5, 4, 3, 2, 1, 0]
```

Ⅸ. 구조 분해  할당(Destructuring assignment)

```jsx
// 구조 분해 할당(Destructuring assignment)
// 구조 분해 할당 구문은 배열이나 객체의 속성을 분해해서
// 그 값을 변수에 담을 수 있게 하는 표현식

// 배열 구조 분해
let [x, y] = [1, 2];

console.log(x); // 1
console.log(y); // 2

// ex.1)
let users = ["Mike", "Tom", "Jane"];
let [user1, user2, user3] = users;
/*let user1 = users[0];
let user2 = users[1];
let user3 = users[2];*/

console.log(user1); // "Mike"
console.log(user2); // "Tom"
console.log(user3); // "Jane"

// ex.2)
let str = "Mike-Tom-Jane";
let [user1, user2, user3] = str.split('-'); // ["Mike", "Tom", "Jane"]

console.log(user1); // "Mike"
console.log(user2); // "Tom"
console.log(user3); // "Jane"

// 배열 구조  분해: 기본값
// 만약 해당하는 값이 없다면❓❓
// undefined 가 할당됨. 
// undefined 대신 기본 값을 지정해주면 됨
let [a, b, c] = [1, 2];
let [a=3. b=4, c=5] = [1,2]; // 각 변수에 미리 기본값을 셋팅함

console.log(a); // 1
console.log(b); // 2
console.log(c); // 5

// 배열 구조 분해: 일부 반환값 무시
// 공백과 ,(쉼표)를 이용해서 필요하지 않은 배열을 무시할 수 있음
let [user1, ,user2] = ['Mike', 'Tom', 'Jane', 'Tony'];

console.log(user1); // 'Mike'
console.log(user2); // 'Jane'

// 배열 구조 분해: 바꿔치기
// 변수 a와 b의 값을 서로 바꾸고 싶다면❓❓

let a = 1;
let b = 2;

// 변수 c를 임시로 정의하고 a의 값을 미리 저장해놓을 수 있음
let c = a; // 1, 변수 c는 임시
a = b; // b의 값을 a로 옮김
b = c; // c의 값을 b로 옮김

// 구조 분해를 이용하기
[a, b] = [b, a]; // b의 값을 a에 대입, a의 값을 b에 대입

// 객체 구조 분해
let user = {name: "Mike", age: 30};
let {name, age} = user;
/*
let name = user.name;
let age = user.age;
*/

console.log(name); // 'Mike'
console.log(age); // 30

// 객체 구조 분해: 새로운 변수 이름으로 할당
let user = {name: "Mike", age: 30};
/*let {name, age} = user;*/
let {name: userName, age: userAge} = user;

console.log(userName); // 'Mike'
console.log(userAge); // 30

// 객체 구조 분해: 기본값
let user = {name: "Mike", age: 30};
let {name, age, gender = 'male'} = user; // user 객체에 gender 가 없으면 'male'이 기본으로 할당됨.
// 기본값이 있다면❓❓
let user = {
	name: 'Jane',
	age: 18,
	gender: 'female'
};

let {name, age, gender = 'male'} = user;

console.log(gender); // 'female'

```

Ⅹ. 나머지 매개변수, 전개 구문(Rest parameters, Spread syntax)

```jsx
// 인수 전달
function showName(name){ // JS에선 인수의 갯수 제한이 없음
	console.log(name);
}

showName('Mike'); // 'Mike'
showName('Mike', 'Tom'); // 'Mike'
showName(); // undefined

// 함수에 인수를 얻는 방법은 2가지 방법이 있음
// 1. arguments
// 2. 나머지 매개 변수

// arguments
// 함수로 넘어 온 모든 인수에 접근
// 함수내 이용 가능한 지역 변수
// length / index
// Array 형태의 객체
// 배열의 내장 메서드 없음(forEach, map 에서 사용할 수 없음)
function showName(name){
	console.log(arguments.length); // 2
	console.log(arguments[0]); // 'Mike'
	console.log(arguments[1]); // 'Tom'
}

showName('Mike', 'Tom');

// 🌐나머지 매개변수(Rest parameters)
// 정해지지 않은 인수의 갯수를 배열로 나타나게 해줌
// 나머지 매개변수는 항상 인수 마지막에 있어야함
function showName(...names){ //// ... 점 3개를 찍고, 배열 이름을 적어줌
	console.log(names);
}

showName(); // [], 아무것도 적지않으면 빈 배열로 나타냄
showName('Mike'); // ['Mike']
showName('Mike', 'Tom'); // ['Mike', 'Tom']

// ex.1)
// 전달받은 모든 수를 더해야함
function add(...numbers){ // 인수들은 numbers의 배열이 됨.
	let result = 0;
	numbers.forEach((num) => (result += num)); // numbers 배열의 요소를 num에 넣어 배열을 돌림
	console.log(result);
}

//또는 reduce()를 이용해서
function add(...numbers){
	let result = numbers.reduce((prev, cur) => prev + cur);
	console.log(result);
}

add(1, 2, 3); // 6
add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // 55

// ex.2)
// user 객체를 만들어 주는 생성자 함수를 만듬
function User(name, age, ...skills){
	this.name = name;
	this.age = age;
	this.skills = skill;
}

const user1 = new User('Mike', 30, 'html', 'css');
const user2 = new User('Tom', 20, 'JS', 'React');
const user3 = new User('Jane', 10, 'English');

console.log(user1); // {name: "Mike", age: 30, skills: ["html", "css"]}
console.log(user2); // {name: "Tom", age: 20, skills: ["JS", "React"]}
console.log(user3); // {name: "Jane", age: 10, skills: "[English]"}

// 전개 구문(Spread syntax): 배열
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];

let result = [...arr1, ...arr2];
console.log(result); // [1, 2, 3, 4, 5, 6];

let result = [0, ...arr1, ...arr2, 7, 8, 9];
console.log(result); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// 전개 구문(Spread syntax): 객체
let user = {name: 'Mike'};
let mike = {...user, age: 30};

console.log(mike); // {name: 'Mike', age: 30}

// 전개 구문(Spread syntax): 복제
let arr = [1, 2, 3];
let arr2 = [...arr]; // [1, 2, 3]

let user = {name: 'Mike', age: 30};
let user2 = {...user};

user2.name = "Tom";

console.log(user.name); // "Mike"
console.log(user2.name); // "Tom"

// ex.3)
// arr1 을 [4,5,6,1,2,3]으로
let arr1 = [1,2,3];
let arr2 = [4,5,6];

/*arr2.reverse().forEach(num => {
	arr1.unshift(num);
});*/

arr1 = [...arr2, ...arr1];
console.log(arr1);[4,5,6,1,2,3]

console.log(arr1); // [4,5,6,1,2,3]

// ex.4)
let user = {name: "Mike"};
let info = {age: 30};
let fe = ["JS", "React"];
let lang = ["Korean", "English"];

/*user = Object.assign({}, user, info, {skills: []});

fe.forEach(item => {
	user.skills.push(item);
});
lang.forEach(item => {
	user.skills.push(item);
});*/

user = {
	...user,
	...info,
	skills: [...fe, ...lang]
};

console.log(user); // {name: "Mike", age: 30, skills: ["JS", "React", "Korean", "English"]}

```

Ⅺ. 클로저(Closur)

```jsx
// JS는 어휘적 환경(Lexical Envionment)를 가진다
// 예제1)
let one;
one = 1;

function addOne(num){
	console.log(one + num);
}

addOne(5); // 6
// 1. 코드를 실행하면 스크립트내 변수들(one: 초기화X(사용불가), addOne: function(사용가능))이 'Lexocal 환경'에 올라감
// 2. "let one"를 만나면 초기값으로 "undefined"를 얻음, 사용가능
// 3. 변수 one에 숫자 "1"이 할당됨.
// 4. 함수 선언은 초기에 이미 선언되었기 때문에 맨 마지막으로 가서 "함수를 실행함"
// 5. 그 순간 "새로운 Lexical환경"이 만들어지며, 함수로 넘겨받은 매개변수와 지역변수를 저장함.(num: 5)
// 6. 함수가 호출되는 동안, 함수에서 만들어진 "내부"Lexical 환경과 외부에서 받은 "외부"Lexical 환경 2개를 가짐.
// 7. "내부"Lexical 환경은 "외부"Lexical 환경에 대한 참조를 갖음.
// 8. 현재 코드에서는 one과 num은 값을 우선  "내부"Lexical 환경에서 찾음
// 9. num은 찾았지만, one은 없음
// 10. one은 외부 그리고 전역 순으로 해당 값을 찾아 나섬

// 예제2)
function makeAdder(x){
	return function(y){
		return x + y;
	}
}

const add3 = makeAdder(3);
console.log(add3(2)); // 5
// 1. 최초 실행시 "makeAdder 함수"와 "변수 add3(초기화X, 사용가능X)"은 "전역"Lexical 환경에 들어감.
// 2. "const add3 = makeAdder(3);" 코드가 실행될 때, "makeAdder() 함수"가 실행되고,
// 3. "makeAdder Lexical 환경"이 만들어지며, 여기에 전달받은 "x의 값 3"이 들어감.
// ⚠함수의 Lexical 환경에는 "넘겨받은 매개변수"와 "지역변수" 들이 저장됨.⚠
// 4. "전역"Lexical 환경의 "add3"은 함수가 실행됨으로써 "return 하는 함수(x+y)가 됨."
// 5. "console.log(add3(2));"를 실행하면, "return function(y){ return x + y;}"이 실행되고,
// 6. 이때 "익명"Lexical 함수가 만들어지며, 전달받은 "y의 값 2"가 들어감.

//풀이
function makeAdder(x){
	return function(y){ // 이 함수는 자신이 y를 가지고 있고, 상위함수인 makeAdder의 x에 접근 가능
		return x + y;
	}
}

const add3 = makeAdder(3);
console.log(add3(2)); // 5, add3 함수가 생성된 이후에도 상위함수인 makeAdder의 x에 접근 가능 

const add10 = makeAdder(10);
console.log(add10(5)); // 15
console.log(add3(1)); // 4

// 클로저(Closure)
// 함수와 Lexical 환경의 조합
// 함수가 생성될 당시의 외부 변수를 기억하고,
// 생성 이후에도(외부 함수가 끝난 뒤에도 내부힘수가 외부함수의 변수에) 계속 접근이 가능

//ex.4)
function makeCounter(){
	let num = 0; // 은닉화

	return function(){
		return num++; // 내부 함수가 외부 함수의 변수 "num"에 계속 접근이 가능함.
	}
}

let counter = makeCounter(); // 여기서 외부 함수가 생성된 뒤에도
let counter2 = makeCounter(); 

console.log(counter()); // 0 // 계속해서
console.log(counter()); // 1 // 계속 해서
console.log(counter()); // 2 // 기억함
console.log(counter2()); // 0
```

Ⅻ. setTimeout / setInterval

```jsx
// setTimeout / setInterval
// setTimeout: 일정 시간이 지난 후 함수를 실행
// setInterval: 일정 시간 간격으로 함수를 실행

// setTimeout 
function fn(){
	console.log(3);
}

setTimeout(fn, 3000); // 3000 == 3s, 2개의 매개변수, 첫 번째는 일정시간이 지난 뒤 실행되는 함수, 두 번째는 시간

// 함수를 전달하지 않고 직접 함수를 작성해도 됨
setTimeout(function => {
	console.log(3);
}, 3000);

// 실행할 함수에 인수가 필요하다면❓❓❓
function showName(name){
	console.log(name);
}

const tId = setTimeout(showName, 3000, 'Mike'); // 시간 뒤에 '인수'를 적어줌, 'Mike' -> name 인수로 전달됨

clearTimeout(tId); // tId를 clearTimeout에 넣음으로써 예정된 작업을 취소할 수 있음
// 예정된 작업을 없앰

// setInterval
function showName(name){
	console.log(name);
}

const tId = setInterval(showName, 3000, 'Mike'); // 3초마다 계속 반복 실행됨

// clearInterval
// clearTimeout과 마찬가지로 예약된 작업을 취소함
clearInterval(tId); // tId를 clearInterval에 넣음으로써 예정된 작업을 취소할 수 있음 

// ⚠⚠주의사항⚠⚠
// delay = 0, 딜레이타임을 0으로 준다면 바로 실행할까❓❓❓
setTimeout(function(){
	console.log(2); // 2. console.log(2)가 나중에 찍힘
}, 0);

console.log(1); // 1. console.log(1)이 먼저 찍힘

// 왜❓❓❓
// 현재 실행중인 스크립트를 우선❗ 실행한 후
// 스케쥴링된(예약된) 함수를 실행 함❗
// 또한 브라우저는 보통 4ms~ 이상의 딜레이가 있음
// 그래서 '0'이라 적어도 바로 실행되지 못함

// ex.1)
let num = 0;
 function showTime(){
		console.log(`안녕하세요. 접속하신지 ${num++}초가 지났습니다.`);
		if(num > 5){ // num의 숫자가 5보다 커지면 clearInterval가 실행되면서 끝남
			clearInterval(tId); // 바로 끝남	
		}
		
	}

const tId = setInterval(showTime, 1000); // "안녕하세요. 접속하신지 xx초가 지났습니다.", 1초마다 반복
```

ⅩⅢ. call, apply. bind

```jsx
// call, apply. bind
// 함수 호출 방식과 관계없이 this를 지정할 수 있음

// call
const mike = {
	name: "Mike"
};

const tom = {
	name: "Tom"
};

function showThisName(){
	console.log(this.name);
}

showThisName(); // 아무것도 안뜸, 여기서 this는 window를 가르킴
showThisName.call(mike); // "Mike"
// 함수를 호출하면서 "call"를 사용하고
// this로 사용할 객체를 매개변수로 넘기면
// 해당 함수가 주어진 객체의 메소드인것 처럼 사용할 수 있음.
// call의 첫 번째 매개변수는 this로 사용할 값이고
// 매개변수가 더 있으면, 그 매개변수를 호출하는 함수로 전달됨.
showThisName.call(tom); // "Tom"

function update(birthYear, occupation){
	this.birthYear = birthYear;
	this.occupation = occupation;
};

update.call(mike, 1999, 'singer');
console.log(mike); // {name: "Mike", birthYear: 1999, occupation: "singer"}

update.call(tom, 2002, 'teacher');
console.log(tom); // {name: "Tom", birthYear: 2002, occupation: "teacher"}
// call() 함수의 첫 번째 매개변수는 this에 사용될 값
// 두 번째 매개변수부터는 call() 앞 함수가 사용할 매개변수를 사용할 값으로 사용

// apply
// apply는 함수 매개변수를 처리하는 방벙을 제외하면 call과 완전히 같음.
// call은 일반적인 함수와 마찬가지로 매개변수를 직접 받지만, apply는 매개변수를 배열로 받음.
// ex.1)
const mike = {
	name: "Mike"
};

const tom = {
	name: "Tom"
};

function showThisName(){
	console.log(this.name);
}

function update(birthYear, occupation){
	this.birthYear = birthYear;
	this.occupation = occupation;
};

// apply를 사용할 땐, 사용할 매개변수를 배열로 만든다.
update.apply(mike, [1999, 'singer']); // {name: "Mike", birthYear: 1999, occupation: "singer"}
console.log(mike);

update.apply(tom, [2002, 'teacher']); // {name: "Tom", birthYear: 2002, occupation: "teacher"}
console.log(tom);

// ex.2)
const minNum = Math.min(3, 10, 1, 6, 4);
const maxNum = Math.max(3, 10, 1, 6, 4);

console.log(minNum); // 1
console.log(maxNum); // 10

// ex.3)
const nums = [3, 10, 1, 6, 4];
const minNum = Math.min(...nums);
const maxNum = Math.max(...nums);

console.log(minNum); // 1
console.log(maxNum); // 10

// apply() 적용
const nums = [3, 10, 1, 6, 4];

const minNum = Math.min.apply(null, nums); //max, min은 this가 필요하지 않아서, 첫 번째 매개변수에 아무거나 넣은거
// = Math.min.apply(null, [3, 10, 1, 6, 4]);
const maxNum = Math.max.apply(null, nums);
// = Math.max.apply(null, [3, 10, 1, 6, 4]);

console.log(minNum); // 1
console.log(maxNum); // 10

// call과 apply는 동작 방식은 같음.
// 매개변수를 받는 방식만 다름
// call은 매개변수를 하나씩 순서대로❗❗ 
// apply는 매개변수를 array로 받는다❗❗

// bind
// 함수의 this 값을 영구히 바꿀 수 있음.
// ex.1)
const mike = {
	name: "Mike"
}

function update(birthYear, occupation){
	this.birthYear = birthYear;
	this.occupation = occupation;
};

const updateMike = update.bind(mike); // 이 함수는 this를 항상 "Mike"로 받음
updateMike(1980, 'police');
console.log(mike); // {name: "Mike", birthYear: 1980, occupation: "police"}

// ex.2)
const user = {
	name: "Mike",
	showName: function(){
		console.log(`hello, ${this.name}`);
	}
};

user.showName(); // "hello, Mike"

let fn = user.showName;
fn(); // "Hello, ", user.showName;를 fn에 할당하면서 user.showName의 this를 잃어버림
// 메소드는 ".(점)앞에 있는게" this이다.
fn.call(user); // "Hello, Mike"
fn.apply(user); // "Hello, Mike"

let boundfn = fn.bind(user);
console.log(boundfn); // "Hello, Mike"
```

ⅩⅣ. 상속, prototype

```jsx
const user = {
	name: 'Mike'
};

user.name; // "Mike"

// hasOwnProperty()
// 객체가 ()안의 프로퍼티를 가지고 있는지 확인하는 함수
user.hasOwnProperty('name'); // true
user.hasOwnProperty('age'); // false
// hasOwnProperty()는 만든적도 없는데 어디서 튀나옴❓❓
// 객체는 사용자가 지정한 프로퍼티가 없으면,
// 그 다음 "__proto__" 에서 프로퍼티를 찾음
const user = {
	name: "Mike",
	hasOwnProperty: function(){
		console.log('haha');
	}
};

user.hasOwnProperty(); // "haha"
// 객체에 찾고자하는 프로퍼티가 있으면 탐색 후 끝냄
// 없을때만 "__proto__" 에서 프로퍼티를 찾음

// ex.1)
const car = {
	wheels: 4,
	drive(){
		console.log("drive...")
	}
};

const bmw = {
	color: "red",
	navigation: 1,
};

bmw.__proto__= car;
// car가 bmw의 프로토타입이 됨
// bmw는 car의 상속을 받음
bmw.color; // "red"
bmw.wheels; // 4

// 상속은 계속 가능함
const x5 = {
	color: "white",
	name: "x5"
};

x5.__proto__ = bmw;
x5.name; // "x5"
x5.color; // "white"
x5.navigation; // 1

for(p in x5){
	console.log(p); // color, name, navigation, wheels, drive
}
Object.keys(x5); // ["color", "name"]
Object.values(x5); // ["white", "x5"]

for(p in x5){
	if(x5.hasOwnProperty(p)){
		console.log('o', p) // "o",color / "o",name
	} else {
		console.log('x', p) // "x",navigation / "x",wheels / "x",drive
	}
}

// 생성자 함수를 이용
/*const car = {
	this.wheels = 4;
	this.drive = function(){
		console.log("drive...");
	};
};*/

const Bmw = function(color){
	this.color = color;
};

Bmw.prototype.wheels = 4;
Bmw.prototype.drive = function(){
	console.log("drive...");
};
Bmw.prototype.navigation = 1;
Bmw.prototype.stop = function(){
	console.log("stop!");
};
// 생성자 함수가 생성하는 객체의 "__proto__ "를 wheels, drive() 처럼 설정하겠다는 뜻

/*Bmw.prototype = {
	// constructor: Bmw, // 또는 이런식으로 "constructor" 프로퍼티를 수동으로 명시하자
	wheels: 4,
	drive(){
		console.log("drive...");
	},
	navigation: 1,
	stop(){
		console.log("stop!");
	}
};
*/
// 이런식으로 한번에 prototype를 생성해 인스턴스에 덮어씌우는 경우
// "constructor" 프로퍼티가 없어짐
// 확인이 어려워지니 되도록이면 위의 코드처럼 1개씩 추가하는 방식으로 작성하자❗❗

const x5 = new Bmw("red");
const z4 = new Bmw("blue");

x5.wheels; // 4
x5.drive(); // "drive..."
x5.navigation; // 1
x5.stop(); // "stop!"

// x5.__proto__ = car;
// x5.wheels; // 4
// z4.__proto__ = car;

// 생성자 함수가 새로운 객체를 만들어낼때 
// 그 새로운 객체는 생성자의 "instance" 라고 불림
// instanceof
// instanceof를 이용해 객체와 생성자를 비교할 수 있음
// 해당 객체가 생성자로 부터 생성됬는지를 true/false 값으로 반환함
z4; // Bmw{color: "blue"}
z4 instanceof Bmw // true

// 생성자를 통해 만들어진 instance 객체는 "constructor" 이라는 프로터피가 존재함
z4.constructor === Bmw;  // true
// "constructor" 프로퍼티는 명확하게 보장해주지 않음. 개발자에 의해 언제든지 수정될 수 있음.

// 내가 선언한 자동차의 색깔을 못바꾸게 하려면❓❓
// 클로저를 이용
const Bmw = function(color){
	const c = color;
	this.getColor = function(){
		console.log(c);
	}
};

const x5 = new Bmw('red'); // "red"
```

![<Prototype Chain](%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20%E1%84%8C%E1%85%AE%E1%86%BC%E1%84%80%E1%85%B3%E1%86%B8%20%E1%84%80%E1%85%A1%E1%86%BC%E1%84%8C%E1%85%AA%20140%E1%84%87%E1%85%AE%E1%86%AB%20%E1%84%8B%E1%85%AA%E1%86%AB%E1%84%89%E1%85%A5%E1%86%BC%208f33ca5db9d34d74bad4a242c2983e93/Untitled.png)

<Prototype Chain

ⅩⅤ. 클래스(Class)

```jsx
// 지금까지 비슷한 객체를 생성하기 위해서 생성자 함수를 사용함
const User = function(name, age){
	this.name = name;
	this.age = age;
	this.showName = function(){
		console.log(this.name);
	}
}

const mike = new User("Mike", 30);

// 🌐클래스(Class)를 이용해 사용 가능
// ES6에 추가된 스펙
class User2{
	constructor(name, age){ // "constructor": 객체를 만들어주는 생성자 함수, new를 통해 호출
		this.name = name;
		this.age = age;
	}
	showName(){
		console.log(this.name);
	}
}

const tom = new User2('Tom', 19);

// 생성자 함수를 통해 만들어진 객체의 경우,
// 객체 내부에 showName() 함수가 들어있음.
// Class를 통해 만들어진 객체의 경우
// prototype 내부에 showName() 함수가 들어있음.
mike.showName(); // "Mike"
tom.showName(); // "Tom"

// 생성자함수에서 Class와 동일하게 만들어 보기
const User = function(name, age){
	this.name = name;
	this.age = age;
//	this.showName = function(){
//		console.log(this.name);
//	}
}

User.prototype.showName = function(){
	console.log(this.name);
}

// 왜 생성자함수와 Class를 구분해놓았을까?
// 생성자 함수내 코드에서 오류가 났을 경우, 생성자함수는 undefined를 보냄으로써 오류를 알리지 않음. 개발자는 오류인지 인지하기 어려움
// Class의 경우, 코드 내 오류가 있을 경우 에러 메세지를 보여줌. 개발자가 알아차리기 쉬움

// for...in 문으로 돌려보면❓❓
for(const p in mike){
	console.log(p); // name, age, showName 모두 출력됨
}

for(const p in tom){
	console.log(p); // name, age만 출력됨
}

// 🌐클래스: 상속
// "extends" 키워드를 사용
class Car{
	constructor(color){
		this.color = color;
		this.wheels = 4;
	}
	drive(){
		console.log('drive...');
	}
	stop(){
		console.log('stop!');
	}
}

class Bmw extends Car {
	park(){
		console.log('park');
	}
}

const z4 = new Bmw("blue"); // Bmw{color: "blue", wheels: 4}
z4.drive(); // "drive..."

// Class: 메소드 오버라이딩(method overriding)
// Bmw 내부에 Car에서 정의한 메소드와 동일한 메소드가 존재한다면❓❓
class Car{
	constructor(color){
		this.color = color;
		this.wheels = 4;
	}
	drive(){
		console.log('drive...');
	}
	stop(){
		console.log('stop!');
	}
}

class Bmw extends Car {
	park(){
		console.log('park');
	}
	stop(){
		console.log('off!');
	}
}

const z4 = new Bmw("blue");
z4.stop(); // "off!", 동일한 이름으로 메소드가 존재하면 덮어씌우게 됨.
// 만약 부모의 메소드를 유지하면서, 그 기능을 확장하고 싶다면❓❓
// "super" 를 사용하면 됨
class Car{
	constructor(color){
		this.color = color;
		this.wheels = 4;
	}
	drive(){
		console.log('drive...');
	}
	stop(){
		console.log('stop!');
	}
}

class Bmw extends Car {
	park(){
		console.log('park');
	}
	stop(){
		super.stop(); // 부모 클래스 Car의 stop() 함수를 사용함
		console.log('off!');
	}
}

const z4 = new Bmw("blue");
z4.stop(); // "stop!", "off!"

// Class: 오버라이딩(overriding)
class Car{
	constructor(color){
		this.color = color;
		this.wheels = 4;
	}
	drive(){
		console.log('drive...');
	}
	stop(){
		console.log('stop!');
	}
}

class Bmw extends Car {
	constructor(color){
		super(color); // 부모 Class는 초기 실행 시 {}(빈객체)를 만들고 this의 값을 넣음
		// 자식 Class는 위 과정을 생략하기 때문에 'suepr constructor'를 써줘야함
		// 자식 Class의 super constructor에도 부모 Class의 constructor와 동일하게 매개변수를 넘겨 받아야함
		// 안넣으면 undefined 됨
		this.navigation = 1;
	}
	park(){
		console.log('park');
	}
}

const z4 = new Bmw("blue");
console.log(z4); // Bmw{color: "blue", wheels: 4, navigation: 1}

// 자식 생성자에 constructor가 없다면
// 해당 자식 클래스는 constructor가 있는것 처럼 
// constructor(...args){super(...args)} 와 같이 부모 Class를 참조함
// constructor가 있는 경우, super()를 써주지 않는다면, 부모 Class를 참조하지 않는다고 착각해, 자동으로 참조하지 않음 => 에러
```

ⅩⅥ. 프로미스(Promise)

```jsx
//ex)
// 소비자가 상점에 A 라는 상품을 주문을 한다.
// 상점은 해당 상품을 만드는데 실패 or 성공할 수 있다.
// 소비자는 상품이 어떻게 됬는지 매번 물어본다
// 상점은 해당 상품의 상태에 따라 준비, 실패 또는 성공이라 답한다.
// 비효율....🤔
// 소비자는 해당 상점에 연락처를 남기고 상품이 완료됬을 때 연락달라고 부탁하고 다른 일을 한다.
// 상점은 해당 상품이 완료됬을 때 소비자에게 연락하고 완성된 상품을 전달한다.

const pr = new Promise((resolve, reject) => {
// resolve는 성공했을경우
// reject는 실패했을 시 실행되는 함수
// 어떤일이 완료된 이후 실행되는 함수를 🌐"Callback" 라고 한다.
	// code
});
// new Promise 로 생성

// new Promise 생성자가 반환하는 객체는 "state", "result"를 프로퍼티로 가짐
// "state"는 초기 pending(대기), "result"는 undefined 였다가 "resolve(value)"가 되면
// ✅resolve(value)가 될 경우
// "state"는 fulfilled(이행됨), "result"는 resolve에의해 전달된 value값을 넘겨받음

// ❎reject(error)가 될 경우
// "state"는 rejected(거부됨), "result"는 reject에의해전달된 error 가 됨

// ex.1 resolve(value))
const pr = new Promise((resolve, reject) => {
	setTimeout(() => {
		resolve('OK')
	}, 3000)
});
// 위 코드의 state는 pending(대기) 상태였다가, 3초 뒤 fulfilled(이행됨)으로 바뀜
// result는 undefined 였다가 'OK'가 됨

// ex.2 reject(error))
const pr = new Promise((resolve, reject) => {
	setTimeout(() => {
		reject(new Error('error...'))
	}, 3000)
});
// 위 코드의 state는 pending(대기) 상태였다가, 3초 뒤 refected(거부됨)
// result는 undefined 였다가 'error'가 됨

// "then"를 이용해서 resolve와 reject를 처리할 수 이씅ㅁ
const pr = new Promise((resolve, reject) => {
	setTimeout(() => {
		resolve('OK')
	}, 3000)
});

pr.then(
	function(result){ // Promise가 "이행"되었을 때 실행되는 함수, result에는 'OK'라는 값이 들어옴
		console.log(result + ' 가지러 가자.');	
	}, 
	function(err){ // 거부 되었을 때 실행, err에는 err 값이 들어옴
		console.log('다시 주문해주세요..');
	} 
);

// then 대신에 쓸 수 있는 "catch"
// state가 "reject"인 경우에만 사용 가능
pr.then(
	function(result){}
).catch (
	function(err){} // 2번째로 동작하는 함수를 catch안으로 넣어주면 됨
);

// "finally"
// 이행이든 거부든 처리가 완료되면 항상 실행됨
pr.then(
	function(result){}
).catch (
	function(err){}
).finally(
	function(){
		console.log('---주문 끝---'); // 로딩화면을 없앨 때 유용
	}
);

// ex.1)
const pr = new Promise((resolve, reject) => {
	setTimeout(() => {
		resolve('OK');
	}, 1000)
});

console.log("시작");
pr.then(
	function(result) => {
		console.log(result);
})
	.catch ((err) => {
		console.log(err);
})
	.finally(() => {
	console.log("끝");
});
// "시작"
// "OK"
// "끝"

// ex.2)
// reject로 변경
const pr = new Promise((resolve, reject) => {
	setTimeout(() => {
		// resolve('OK');
		reject(new Error('err...'));
	}, 1000)
});

console.log("시작");
pr.then(
	function(result) => {
		console.log(result);
})
	.catch ((err) => {
		console.log(err);
})
	.finally(() => {
	console.log("끝");
});
// "시작"
// Error: "err..."
// "끝"

// ex.3)
const f1 = (callback) => {
	setTimeout(function(){
		console.log("1번 주문 완료");
		callback();
	}, 1000);
};

const f2 = (callback) => {
	setTimeout(function(){
		console.log("2번 주문 완료");
		callback();
	}, 3000);
};

const f3 = (callback) => {
	setTimeout(function(){
		console.log("3번 주문 완료");
		callback();
	}, 2000);
};

console.log('시작');
f1(function(){
	f2(function(){
		f3(function(){
			console.log("끝");
		})
	})
});

// "시작"
// "1번 주문 완료"
// "2번 주문 완료"
// "3번 주문 완료"
// "끝"

// 이런식으로 depth가 깊어지면서 계속 callback를 호출하는 것을 "Callback Hell(콜백 지옥)"이라 한다.

// callback()함수를 promise로 구현
const f1 = () => {
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("1번 주문 완료"); // res 값: "1번 주문 완료" 담김
		}, 1000);
	}); 
};

const f2 = (message) => {
	console.log(message); // res 값: "1번 주문 완료" 출력됨
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("2번 주문 완료"); // res 값: "2번 주문 완료" 담김
		}, 3000);
	}); 
};

const f3 = (message) => {
	console.log(message); // res 값: "2번 주문 완료" 출력
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("3번 주문 완료");
		}, 2000);
	}); 
};

// 프로미스 체이닝(Promise chaining)
console.log('시작');
f1()
.then(res => f2(res)) // f1은 Promise을 반환하고, resolve을 실행하면서 넘겨준 값을 f2에 넘겨줌
.then(res => f3(res)) // f2에 있는 resolve 값을 f3으로 넘겨줌
.then(res => console.log(res)) // 최종 res 값: "3번 주문 완료" 을 console.log로 출력
.catch(console.log)
.finally(() => {
	console.log("끝");
});

// f2를 실패로 돌린다면❓❓❓❓
const f1 = () => {
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("1번 주문 완료"); // res 값: "1번 주문 완료" 담김
		}, 1000);
	}); 
};

const f2 = (message) => {
	console.log(message); // res 값: "1번 주문 완료" 출력됨
	return new Promise((res, rej) => {
			setTimeout(() => {
				// res("2번 주문 완료"); // res 값: "2번 주문 완료" 담김
				rej("xxx");
		}, 3000);
	}); 
};

const f3 = (message) => {
	console.log(message); // res 값: "2번 주문 완료" 출력
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("3번 주문 완료");
		}, 2000);
	}); 
};

console.log('시작');
f1()
.then(res => f2(res))
.then(res => f3(res))
.then(res => console.log(res))
.catch(console.log)
.finally(() => {
	console.log("끝");
});
// "시작"
// "1번 주문 완료"
// "xxx"
// "끝"
// f2에서 rejected 된 후 f3은 실행조차 되지 않음

// Promise.all
// 배열안의 모든 작업이 완료될 때까지 기다림
// 하나의 정보라도 누락된 경우, 페이지를 보여줘선 안돼는 경우 사용
console.time('x')
Promise.all([f1(), f2(), f3()]).then((res) => {  // []배열안에 f1,f2,f3를 모두 담고, 헤당 함수들이 모두 작동이 끝난 후 then이 실행됨.
	console.log(res); // ["1번 주문 완료", "2번 주문 완료", "3번 주문 완료"]
	console.timeEnd('x'); // 걸린 시간 측정, 3001.15231... ms
})

// Promise.race
// 배열 중 하나도 완료되면 완료된 것을 먼저 실행하고 끝냄
// 용량이 큰 이미지들을 로딩하는데, 그중에 1개만 완료되도 보여줘도 되는 경우 사용함
console.time('x')
Promise.race([f1(), f2(), f3()]).then((res) => {
	console.log(res);
	console.timeEnd('x');
})
```

ⅩⅦ. async, await

```jsx
//async, await를 사용하면, Promise에 then 메소드를 체인 형식으로 작성하는것 보다 가독성이 좋아짐
async function getName(){ // 앞에 async를 반환하면 항상 Promise를 반환함
	return "Mike";
}

console.log(getName()); // Promise {<fulfilled>: "Mike"}

getName().then((name) => {
	console.log(name); // "Mike"
})

// 만약 return 값이 Promise라면 그 값을 그대로 사용
async function getName(){ 
	return Promise.resolve("Tom");
}

getName().then((name) => {
	console.log(name); // "Tom"
})

// 만약 함수 내부에서 예외 상황이 발생한다면 rejected를 반환함
async function getName(){ 
	// return Promise.resolve("Tom");
	throw new Error("err...");
}

getName().catch((err) => {
	console.log(err); // Error: err...
})

// await
// "await" 키워드는 async 안에서만 사용가능
// 일반함수 안에서 사용 시 에러남
function getName(name){
	return new Promise((resolve, reject) => {
			setTimeout(() => {
				resolve(name);
		}, 1000);
	}); 
}

async function showName(){
	const result  = await getName('Mike'); // getName()에 resolve된 값을 기다렸다가, result에 넣어줌
// await 키워드 옆에는 Promise가 오고,
// Promise가 다 처리될때까지 기다림
	console.log(result);
}

console.log("시작");
showName();
// "시작"
// (1초 후)"Mike"

// ex.1) async를 이용한 Promise 코드
const f1 = () => {
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("1번 주문 완료");
		}, 1000);
	}); 
};

const f2 = (message) => {
	console.log(message);
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("2번 주문 완료"); 
		}, 3000);
	}); 
};

const f3 = (message) => {
	console.log(message); 
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("3번 주문 완료");
		}, 2000);
	}); 
};

console.log("시작"); // "시작"
async function order(){
	const result1  = await f1();
	const result2  = await f2(result1); // "1번 주문 완료"
	const result3  = await f3(result2); // "2번 주문 완료"
	console.log(result3); // "3번 주문 완료"
	console.log("종료"); // "종료"
}
order();

/*f1()
.then(res => f2(res)) 
.then(res => f3(res)) 
.then(res => console.log(res))
.catch(console.log)*/

// ex.2) async를 이용한 Promise 코드
// reject가 된다면❓❓❓
const f1 = () => {
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("1번 주문 완료");
		}, 1000);
	}); 
};

const f2 = (message) => {
	console.log(message);
	return new Promise((res, rej) => {
			setTimeout(() => {
				// res("2번 주문 완료"); 
				rej(new Error('err...'));
		}, 3000);
	}); 
};

const f3 = (message) => {
	console.log(message); 
	return new Promise((res, rej) => {
			setTimeout(() => {
				res("3번 주문 완료");
		}, 2000);
	}); 
};

console.log("시작"); // "시작"
async function order(){
	try{
		const result1  = await f1();
		const result2  = await f2(result1); // "1번 주문 완료"
		const result3  = await f3(result2); // Error:err...
		console.log(result3);
	}catch(e){
		console.log(e); // 에러 처리
	}
	console.log("종료"); 
}
order();
// try...catch문으로 감싸아서, Error가 발생하면 Error로그를 찍어주고, 이후 작업을 계속 진행함

// Promise.all 사용
console.log("시작"); // "시작"
async function order(){
	try{
		const result = await Promise.all([f1(), f2(), f3()]);
		console.log(result);
	}catch(e){
		console.log(e); // 에러 처리
	}
	console.log("종료"); 
}
order();
```

ⅩⅧ. Generator

```jsx
// Generator
// 함수의 실행을 중간에 멈췄다가  재개할 수 있는 기능
// function 옆에 *(별) 써서 만듬
// Generator 함수를 실행하면, Generator 객체가 반환됨
// Generator 객체는 next()를 가지고 있음 
function* fn(){
	console.log(1);
	yield 1;
	console.log(2);
	yield 2;
	console.log(3);
	console.log(4);
	yield 3;
	return "finish";
}

const a = fn();
console.log(a); 
// fn{<suspended>}, Generator 객체만 반환되고, 함수 내부 코드는 실행되지 않음
a.next(); // 1, 가장 가까운 yield 문을 만날때까지 실행되고, 데이터 객체를 반환함
// 반환된 객체: {value: 1, done: false} value와 done 프로퍼티를 가짐.
// value의 값은 yield 오른쪽에 있는 값을 설정함. 안적으면 undefined
// done은 함수 코드가 끝났는지 나타내며, 끝났다면 true, 끝나지 않았다면 false를 반환함
a.next(); // 2
// 반환된 객체: {value: 2, done: false}
a.next(); // 3, 4
// 반환된 객체: {value: 3, done: false}
a.next();
// 반환된 객체: {value: "finish", done: true}
a.next();
// // 반환된 객체: {value: undefined, done: true}

// next() 외에 return(), throw()를 가지고 있음
// return()
a.next(); // 2
// 반환된 객체: {value: 2, done: false}
a.return('END');
// 반환된 객체: {value: "END", done: true}
// value의 값은 return()의 요소값이 전달되며, done은 true로 바뀐다.
a.next();
// 반환된 객체: {value: undefined, done: true}

// throw()
function* fn(){
	try{
		console.log(1);
		yield 1;
		console.log(2);
		yield 2;
		console.log(3);
		console.log(4);
		yield 3;
		return "finish";
	}catch(e){
		console.log(e);
	}
}

const a = fn();
console.log(a);
a.next(); // 1
// 반환된 객체: {value: 1, done: false}
a.next(); // 2
// 반환된 객체: {value: 2, done: false}
a.throw(new Error('err')) // Error: err
// 반환된 객체: {value: undefined, done: true}
a.next();
// 반환된 객체: {value: undefined, done: true}

// iterable
// 반복이 가능함
// 조건 1. Symbol.iterator 메소드가 있다.
// 조건 2. Symbol.iterator 는 iterator를 반환해야 한다.

// iterator
// 조건 1. next() 메서드를 가진다.
// 조건 2. next() 메서드는 value와 done 속성을 가진 객체를 반환한다.
// 조건 3. 작업이 끝나면 done은 true가 된다.

// ex.1)
const arr = [1,2,3,4,5];
const it = arr[Symbol.iterator]();
it.next(); // {value: 1, done: false}
it.next(); // {value: 2, done: false}
// 배열은 "Symbol.iterator" 메서드를 가지고 있고,
// 이 메서드가 반환하는 값은 iterator 이다.
// iterable 하다!
// 즉, 배열은 반복가능한 객체이다.
// iterable 은 for...of문을 이용해서 반복가능할 수 있다.
for(let num of arr){
	console.log(num); // 1, 2, 3, 4, 5
}

// ex.2)
function* fn(){
	yield 4;
	yield 5;
	yield 6;
}

const a = fn();
a[Symbol.iterator]() === a; // true, a의 Symbol.iterator 메서드를 실행한 값이 a 즉, 자기자신 이다.
// 즉, Generator 는 iterator 이다.
for(let num of a){
	console.log(a); // 4, 5, 6
// for..of문이 실행되면, Symbol.iterator를 호출하고, 
// 만약에 없으면 Error가 발생함.
// 반환된 iterator 에 next() 메소드를 호출하면서,
// done이 true가 될 때까지 반복함.
}

// ex.3)
// 문자열도 가능할까❓❓❓
const str = 'hello';
str[Symbol.iterator](); // f [Symbol.iterator]() {[native code]}
const xx = str[Symbol.iterator]();
xx.next(); // {value: "h", done: false}
xx.next(); // {value: "e", done: false}
xx.next(); // {value: "l", done: false}
xx.next(); // {value: "l", done: false}
xx.next(); // {value: "o", done: false}

for(let s of xx){
	console.log(s); // h, e, l, l, o
}

// 0️⃣next() 메소드에 인수 전달
// Generator는 외부로부터 값을 입력받을 수 있음
function* fn(){
	const num1 = yield "첫 번째 숫자를 입력해주세요.";
	console.log(num1);

	const num2 = yield "두 번째 숫자를 입력해주세요.";
	console.log(num2);

	return num1 + num2;
}

const a = fn();
a.next(); // 
//반환된 객체: {value: "첫 번째 숫자를 입력해주세요.", done: false}
a.next(2); // 2
// 반환된 객체: {value: "두 번째 숫자를 입력해주세요.", done: false}
a.next(4); // 4
// 반환된 객체: {value: 6, done: true}

// 1️⃣Generator는 미리 값을 만들어 두지 않음
// Generator는 필요한 값만 그때그때 생성함
// 일반적으로 함수에서 어떤값을 구할 때, 값을 미리 계산해놔야 함
// 그리고 쓰일지 않쓰일지 정해지지 않은 상황에서도 그 값을 유지해야함
// Generator를 사용하면, 필요한 순간까지 계산을 미룰 수 있음
function* fn(){
	let index = 0;
	while(true){ // 무한 반복 while문에도 브라우저가 뻗지않음
		yield indexx++;
	}
}

const a = fn();
a.next(); // 반환된 객체: {value: 0, done: false}
a.next(); // 반환된 객체: {value: 1, done: false}
a.next(); // 반환된 객체: {value: 2, done: false}
a.next(); // 반환된 객체: {value: 3, done: false}
a.next(); // 반환된 객체: {value: 4, done: false}
a.next(); // 반환된 객체: {value: 5, done: false}
...

// 2️⃣yield*를 이용해서 다른 Generator 호출
function* gen1(){
	yield "W";
	yield "o";
	yield "r";
	yield "l";
	yield "d";
}

function* gen2(){
	yield "Hello,";
	yield* gen1();
	yield "!";
}

console.log(...gen2()); // Hello, W o r l d !

// Generator는 다른 작업을 하다가 다시 돌아와서
// next() 해주면 진행이 멈췄던 부분부터 이어서 실행

ex)Redux Saga
```